# Описание решения

## Алгоритмы и методы решения

В соответствии с заданием, для решения задачи не использовались ML-модели. Основой решения является комбинация регулярных выражений и строковых методов для анализа текста вопроса. Весь процесс можно разделить на несколько ключевых этапов:

### 1. Определение темы вопроса

Первым шагом является определение одной из двух поддерживаемых тем:

1) **Произведение векторов из 3-х компонент**: Определяется по наличию в строке вопроса числовых последовательностей, соответствующих формату вектора (например, `[1, 2, 3]`). Для этого используется регекс.
2) **Площадь поверхности цилиндра**: Тема определяется по наличию в тексте вопроса ключевых слов `cylinder` (или его производных) и `surface area`.

Если вопрос не соответствует ни одной из тем, сервис возвращает ошибку.

### 2. Извлечение параметров

После определения темы из текста вопроса извлекаются необходимые числовые параметры.

-   **Для векторного произведения**: С помощью регулярного выражения `(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)` извлекаются компоненты двух векторов. Реализована логика для обработки дублирующихся векторов в вопросе.
-   **Для площади поверхности цилиндра**: Используется набор из нескольких регексов для нахождения высоты радиуса. Регексы подобраны так, чтобы обрабатывать различные формулировки:
    -   "radius of 5 meters"
    -   "5-meter radius"
    -   "height of 10 meters"
    -   "10 meters tall"
    -   Также поддерживаются специальные значения, такие как "single" (конвертируется в `1.0`) и единицы измерения "storey" (приравнивается к одному метру).

### 3. Вычисление ответа

После извлечения параметров производится вычисление по соответствующим математическим формулам:

-   **Векторное произведение**: $`\vec{v1} \times \vec{v2} = [v1_y \cdot v2_z - v1_z \cdot v2_y, v1_z \cdot v2_x - v1_x \cdot v2_z, v1_x \cdot v2_y - v1_y \cdot v2_x]`$
-   **Площадь поверхности цилиндра**: $`S = 2\pi r(r+h)`$. Для соответствия ответам из `train.json` результат округляется вниз ("floor").

### 4. Кэширование

Реализован механизм кэширования для выполнения требования задачи.

-   **Ключ кэша**: Генерируется путем вычисления **MD5-хэша** от текста вопроса. Это обеспечивает уникальный (с поправкой на коллизии) и компактный ключ для любого вопроса.
-   **Логика**: При поступлении запроса сервис сначала проверяет наличие ответа в кэше.
    -   Если ответ найден (cache hit), он немедленно возвращается клиенту.
    -   Если ответ не найден (cache miss), задача решается, после чего результат сохраняется в кэш со временем жизни **60 секунд** и возвращается клиенту.
-   **Хранилище**: В качестве бэкенда для кэша используется **Redis**.

## Используемые инструменты

-   **Фреймворк**: FastAPI. Почему: быстрый в разработке благодаря встроенной валидации, автоматически генерует интерактивные доки.
-   **Кэш**: Redis. Почему: стадартный выбор для кэша. In-memory кэш подошёл бы для этого маленького тестового, но я старался делать "с прицелом на продакшен". 
-   **Деплой**: Docker Compose. Почему: тоже стандарт; даёт более-менее предсказуемый и однотипный запуск на любой платформе.

## Пререквизиты к системе, на который будет запускаться проект

Свежие версии Docker и Docker Compose, доступ в интернет для загрузки и сборки докер-образов.
